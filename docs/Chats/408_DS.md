---
title: 408代码题学习笔记
description: 使用资料:B站-阿辉不会敲代码
hidden: true
tags:
  - 408
  - 数据结构
---
# 408 代码题学习笔记

## 顺序表

### 顺序表的定义

#### 静态定义顺序表

```c
#define MaxSize 100
typedef struct SqList{
    int data[MaxSize];
    int length;
} SqList;

SqList L;
L.data[0] = 0;
```

#### 动态定义顺序表

```c
typedef struct {
    int *data;
    int MaxSize,length;
} SqList;

SqList L2;
L2.data = (int*)malloc(sizeof(int)*L2.MaxSize);
L2.data[0] = 1;
```

### 顺序表的遍历

```c
void ListVisit(SqList L){
    if(L.length == 0){
        return;
    }
    for(int i = 0; i < L.length; i++){
        printf("%d", L.data[i]);
    }
}
```

### 假设有一个顺序表 L, 请设计一个算法，查找顺序表 L 中第一个值为 x 的元素，若查找成功，则返回其位序，若查找失败，则返回 0。

```c
int Search_X(SqList L,int x){
    if(L.length == 0){
        return 0;
    }
    for(int i = 0; i < L.length; i++){
        if(x == L.data[i]){
            return i+1;
        }
    }
    return 0;
}
```

### 假设有一个顺序表 L, 其存储的所有数据元素均为非 0 整数，请设计一个算法，查找 L 中第 i 个元素并返回其值。

```c
int Search_I(SqList L, int i){
    if(L.length == 0){
        return 0;
    }
    // 合法
    if(i <= L.length && i > 0){
        return L.data[i-1];
    }
    // 非法
    return 0;
}
```

### 假设有一个顺序表 L, 请设计一个算法，在 L 的第 i 个位置插入新元素 x。若不能正常插入，则返回 false, 表示插入失败；若能够正常插入，则在顺序表 L 中的第 i 个位置插入新元素 x, 返回 true, 表示插入成功。

```c
bool ListInsert(SqList &L,int i,int x){ // 改变L需要加&
    if(i < 1 || i>L.length || L.MaxSize == L.length){
        return false;
    }
    // 从后往前遍历
    for(j = L.length;j >= i; j--){
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = x;
    L.length++;
    return true;
}
```

### 假设有一个非空顺序表 L, 其中的元素非递减有序排列，请设计一个算法在插入元素 x 后保持该顺序表仍然非递减有序排列，假设插入操作肯定成功，插入成功后返回插入元素所在位置。

```c
int ListInsert(SqList &L, int x){
    int i;
    for(i = L.length; i > 0 && L.data[i-1]>=x; i--){
        L.data[i] = L.data[i-1];
    }
    L.data[i+1] = x;
    L.length++;
    return i+1;
}
```

另有

```c
int ListInsert(SqList &L, int x){
    int i;
    // 找到插入位置i
    for(i = 0; i < L.length; i++){
        if(L.data[i] > x){
            break;
        }
    }
    // 移动i+1后面的元素
    for(int j = L.length; j>=i+1; j--){
        L.data[j] = L.data[j-1];
    }
    return i;
}
```

### 删除顺序表 L 中第 i 个位置的元素，若删除失败，则返回 false; 若删除成功，则将被删元素的值赋给引用参数 x, 然后返回 true。

```c
bool Delete_I(SqList &L, int &x, int i){
    if(L.length == 0 || i < 1 || i > L.length){
        return false;
    }
    x = L.data[length-1];
    for(int j = i; j < L.length; j++){
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}
```

### 假设有一个顺序表 L, L 有最小值且最小值唯一，请设计一个算法删除 L 中的最小值元素并由函数返回被删元素的值。

```c
int Delete_min(SqList &L){
    int min = L.data[0]; // 最小值是谁
    int pos = 0; // 初始位置是哪
    for(int i = 1; i < L.length; i++){
        if(min > L.data[i]){
            min = L.data[i];
            pos = i;
        }
    }
    for(int j = pos; j < L.length; j++){
        L.data[j] = L.data[j+1];
    }
    L.length--;
    return min;
}
```

### 假设有一个顺序表 L, 请编写一个时间复杂度为 O(以、空间复杂度为 O(1)的算法，删除顺序表 L 中所有值为 x 的元素。

```c
// 排队法
void Del_x(SqList &L,int x){
    if(L.length == 0){
        return;
    }
    int j = 0;
    for(int i = 0;i <= L.length;i++){
        if(L.data[i] != x){
            L.data[j] = L.data[i];
            j++;
        }
    }
    L.length = j;
}
```

### 假设有一个顺序表 L, 请设计一个算法删除 L 中元素值在给定值 s 与 t 之间（包含 s 和 t, 要求 s < t)的所有元素，若顺序表为空或给定的 s 和 t 值不合理，则返回 false, 若执行成功则返回 true。

```c
// 计数法
bool Delete_Between(SqList &L, int s, int t){
    if(L.length == 0 || s >=t || s < 1 || t >= L.length){
        return false;
    }
    int p = 0;
    for(int i = 0; i >= 0; i++){
        if(L.data[i] >= s && L.data[i] <= t){
            p++;
        }else {
            L.data[p] = L.data[i];
        }
    }
    L.length = L.length - p;
    return true;
}
```

### 请设计一个算法，在一个有序顺序表中删除所有值重复的元素，使该顺序表中所有元素的值均不同

```c
void Del_Iterate(SqList &L){
    if(L.length <= 1){
        return;
    }
    int j = 1;
    for(int i = 1; i < L.length; i++){
        if(L.data[i] != L.data[i-1]){
            L.data[j] = L.data[i];
        }
    }
    L.length = j;
}
```

### 请设计一个算法，在一个无序顺序表中删除所有值重复的元素，使该顺序表中所有元素的值均不同且删除后的元素间相对位置保持不变。

```c
// 排队法
void Del_Iterate(SqList &L){
    if(L.length <= 1){
        return;
    }
    int k = 1; // 新顺序表的长度
    int j; // 让第一层循环能够获取j
    for(int i = 1; i <= L.length; i++){
        for(j = 1; j < i; j++){
            if(L.data[i] == L.data[j]){
                break; // 停止比较
            }
        }
        if(j == i){ // 没有重复值
            L.data[k] = L.data[i]; // 重排
            k++;
        }
    }
    L.length = k;
}
```

### 请设计一个尽可能高效的算法，将顺序表 L 中的所有元素逆置，要求算法的空间复杂度为 O(1)

```c
void Reverse(SqList &L){
    if(L.length == 0){
        return;
    }
    for(int i = 0,j = L.length - 1; i < j; i++,j--){ // 定义双变量
        temp = L.data[i];
        L.data[i] = L.data[j];
        L.data[j] = temp;
    }
}
```

### 已知一个一维数组 A [m+n] 中依次存放了两个线性表(a1, a2,…, am)和(b1, b2,…, bn), 请设计一个算法，将数组中的两个线性表位置互换，即设计一个算法将原数组(a1, a2,…, am, b1, b2,…, bn)变为(b1, b2,…, bn, a1, a2,…, am)。

法一:

```c
void Swap(int A[], int m, int n){
    int B[m+n];
    for(int i = 0, i < m+n, i++){
        B[i] = A[i];
    }
    for(int i = m, i < m+n, i++){
        A[i - m] = B[m];
    }
    for(int i = 0; i < m; i++){
        A[i + m] = B[i];
    }
}
```

法二:

```c
// 三次逆置,无辅助数组
void Reverse(int A[], int low, int high){
    int temp;
    for(int i = low, int j = high, i < j, i++,j--){
        temp = A.data[i];
        A.data[i] = A.data[j];
        A.data[j] = temp;
    }
}

void Swap(int A[], int m, int n){
    Reverse(A[], 0, m-1);
    Reverse(A[], m, m+n-1);
    Reverse(A[], 0, m+n-1);
}
```

### 现有两个非递减有序的顺序表 A 和 B, 请设计一个算法，将两个顺序表 A 和 B 合并为一个新的 <span style="color:#FF0000;"> 非递减 </span> 有序顺序表 C。

```c
// 这是题目给出的表的结构
typedef struct {
    int *data;
    int length,MaxSize;
} SqlList;

void Merge(SqlList A, SqList B, SqList &C){
    if(A.length == 0 && B.length == 0 || A.length+B.length > C.MaxSize){
        return false;
    }
    int i=0,j=0,k=0; // 循环变量
    while(i < A.length && j < B.length){
        if(A.data[i] <= B.data[j]){
            C.data[k] = A.data[i];
            k++;
            i++;
        }else {
            C.data[k] = B.data[j];
            k++;
            j++;
        }
    }
    while(i < A.length){
        C.data[k] = A.data[i];
        k++;
        i++;
    }
    while(j < B.length){
        C.data[k] = B.data[j];
        k++;
        j++;
    }
    C.length = k;
    return true;
}
```

### 现有两个非递减有序的顺序表 A 和 B, 请设计一个算法，将两个顺序表 A 和 B 合并为一个新的 <span style="color:#FF0000;"> 非递增 </span> 有序顺序表 C。

```c
void Merge(SqlList A, SqList B, SqList &C){
    if(A.length == 0 && B.length == 0 || A.length+B.length > C.MaxSize){
        return false;
    }
    int i = A.length - 1;
    int j = B.length - 1;
    int k = 0;
    while(i >=0 && j >=0){
        if(A.data[i] >= B.data[j]){
            C.data[k] = A.data[i];
            k++;
            i--;
        }else {
            C.data[k] = B.data[j];
            k++;
            j--;
        }
    }
    while(i >= 0){
        C.data[k] = A.data[i];
        k++;
        i--;
    }
    while(j >= 0){
        C.data[k] = B.data[j];
        k++;
        j--;
    }
    C.length = k;
    return true;
}
```

### 给定三个序列 A、B、C, 三个序列的长度均 n 为且每个序列都是递增的，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。例如，数组 A 为{4,2,3,6}，数组 B 为{-5,0,2,6}，数组 C 为{1,2,4,6}，则逐行输出 2 和 6。

```c
// 暴力解就是3个for循环
// ...
//较小值向较大值靠拢
int max(int A, int B, int C){
    int max;
    if(A > B){
        max = A;
    } else {
        max = B;
    }
    if(max > C){
        return max;
    } else {
      return C;  
    }
}

void PrintSame(int A[], int B[], int C[]){
    int i=0,j=0,k=0;
    int m;
    while(i<A.length && j<B.length && k<C.length){
        if(A.data[i] == B.data[j] && A.data[i] == C.data[k]){
            printf("%d/n",A.data[i]);
        }
        m = max(A.data[i],B.data[j],C.data[k])
        if(A.data[i]<m){
            i++;
        }
        if(B.data[j]<m){
            j++;
        }
        if(C.data[k]<m){
            k++;
        }
    }
}
```

## 链表

### 单链表的结构体定义

```c
typedef struct LNode{
    int data;
    struct LNode *next;
} LNode,*LinkList;

// struct LNode -> Lnode
// struct LNode* -> LinkList
// LinkList p -> LNode *p
    
// 带头结点
void InitList1(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
}

bool IsEmptyList1(LinkList L){
    if(L->next == NULL){
        return true;
    }else {
        return false;
    }
}
// 不带头结点
void InitList2(LinkList &L){
    L = NULL;
}

bool IsEmptyList2(LinkList &L){
    if(L == NULL){
        return true;
    }else {
        return false;
    }
}

// 注:链表不存在L.data之类操作
```

### 遍历输出单链表 L 中的值

```c
void LNodeList(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *p = L->next;
    while(p != NULL){
        printf("%d",p->data);
        p = p->next;
    }
}
```

### 请设计一个算法，查找一个带头结点的单链表 L 中第 i 个数据结点的位置，若存在，则返回指向该结点的指针，若不存在，则返回 NULL

```c
LNode *Search_i(LinkList L, int i){
    if(L->next == NULL || i < 1){ // 判空
        return;
    }
    LNode *p = L->next;
    int k = 1;
    while(p != NULL){
        if(i = k){
            return p;
        }
        p = p->next;
        k++;
    }
    return NULL; // 说明 i 太大了
}
```

### 计算带头结点的单链表 L 中数据结点的个数。

```c
int DataNum(LinkList L){
    if(L->next == NULL){
        return 0;
    }
    LNode *p = L->next;
    int k = 0;
    while(p != NULL){
        p = p->next;
        k++;
    }
    return k;
}
```



### 在一个带头结点的非递减有序单链表中插入一个值为 x 的新结点，使得插入新结点后链表依然非递减有序

```c
void InsertList(LinkList &L, int x){
    LNode *p = L->next, *pre = L;
    while(p != NULL){
        if(p->data > x){
            break;
        }
        pre = p;
        p = p->next;
    }
    LNode *s = (LNode*)malloc(sizeof(LNode));
    s->data = x;
    s->next = p;
    pre->next = s;
}
```

### 采用头插法在头指针 L 处建立一个带头结点的单链表，输入-1 表示结束，头插结束后返回建立的单链表。

```c
LinkList HeadInsert(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    LNode *x
    int i;
    scanf("%d",&i);
    while(i != -1){
        x = (*LNode)malloc(sizeof(LNode));
        x->data = i;
        x->next = L->next;
        L->next = i;
        scanf("%d",&i);
    }
    return L;
}
```

### 采用尾插法在头指针 L 处建立一个带头结点的单链表，输入-1 表示结束，尾插结束后返回建立的单链表。

```c
LinkList TailInsert(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    LNode *r = L; // 尾指针
    LNode *s;
    int x;
    scanf("%d",&x);
    while(x == -1){
        s = (LNode*)malloc(sizeof(LNode)) // 为结点分配内存空间
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL; // 尾结点的next指针置空
    return L;
}
```

### 试编写算法将一个带头结点的单链表 L 就地逆置，所谓“就地”是指空间复杂度为 O(1)。

```C
void Reverse(LinkList &L){
    if(L->next == NULL){
        return;
    }
    LNode *p = L->next,*r;
    L->next = NULL; // 将尾结点next置空
    while(r->next = NULL){
        r = p->next; // 防断链指针
        p->next = L->next;
        L->next = p;
        p = r;
    }
}
```

### 将一个带头结点的单链表 A 分解为两个带头结点的单链表 A 和 B, 使得 A 表中含有原表中位序为奇数的结点，B 表中含有原表中位序为偶数的结点，且保持结点间相对顺序不变，最后返回 B 表，

```c
LinkList Reverse(LinkList &L){
    if(L->next = NULL){
        return NULL;
    }
    LinkList B = (LinkList)malloc(sizeof(LNode));
    LNode *p = A->next;
    LNode *ra = A,*rb = B;
    while(p != NULL){
        ra->next = p;
        ra = p;
        p = p->next;
        if(p != NULL){ // 单链表奇数或偶数
            rb->next = p;
            rb = p;
            p = p->next;
        }
    }
    ra->next = NULL; // 尾指针置空
    rb->next = NULL;
}
```

### 编写算法将一个带头结点的单链表 A ={a1, b1, a2, b2,..., an, bn}分解为两个带头结点的单链表 A 和 B 使得 A ={a1, a2,…, an}, B ={bn,…, b2, b1}, 原 A 表中结点个数不一定为偶数。

```c
// 对A使用尾插法(正序),对B使用头插法(逆序)
LinkList Split(LinkList A){
    if(A->next == NULL){
        return NULL;
    }
    LinkList B = (LNode *)malloc(sizeof(LNode));
    B->next = NULL;
    LNode *p = A->next,*r = A,*q;
    while(p != NULL){
        r->next = p;
        r = p;
        p = p->next;
        while(p != NULL){
            q = p->next; // 防断链指针
            p->next = B->next;
            B->next = p;
            p = q;
        }
    }
    r->next = NULL;
    return B;
}
```

### 将一个带头结点的单链表 L 分解为两个带头结点的单链表 A 和 B, 使得 A 表中含有原表中数据域为奇数的结点，而 B 表中含有原表中数据域为偶数的结点，且保持相对顺序不变，最后删除单链表 L 的头结点。

```c
void Split(LinkList L,LinkList &A,LinkList &B){
    if(L->next == NULL){
        return;
    }
    // 分配空间
    A = (LinkList)malloc(sizeof(LNode));
    B = (LinkList)malloc(sizeof(LNode));
    // 定义指针
    LNode *p = L->next,*ra = A,*rb = B;
    while(p != NULL){
        if(p->data % 2 != 0){
            ra->next = p;
            ra = p;
        }else{
            rb->next = p;
            rb = p;
        }
        p = p->next;
    }
    ra->next = NULL;
    rb->next = NULL;
    free(L);
}
```

### 有一个带头结点单链表 L，L 中各个结点的值都不相同，请设计一个算法，删除链表 L 中的最小值结点。

```c
void Del_Min(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *minpre = L,*minp = L->next;
    LNode *pre = L->next,*p = pre->next;
    while(p != NULL){
        if(p->data < minp->data){
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    minpre->next = minp->next;
    free(minp);
}
```

### 请设计一个算法，在带头结点的单链表 L 中删除所有值为 x 的结点，并释放其空间。

```c
void Del_x(LinkList L, int x){
    if(L->next == NULL){
        return;
    }
    LNode *pre = L,p = L->next;
    while(p != NULL){
        if(p->data = x){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 请设计一个算法，在带头结点的单链表 L 中删除所有数据域的值介于给定的两个值之间的结点，并释放其空间。

```c
void Del_min_max(LinkList L,int min,int max){
    if(L->next == NULL || min >= max){
        return;
    }
    LNode *pre = L,*p = L->next;
    while(p != NULL){
        if(p->data >= min && p->data <= max){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 请设计一个算法，在带头结点的非递减有序单链表 L 中删除所有值重复的结点，使值重复的结点只保留一个。

```c
void Del_Same(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *pre = L->next,*p = pre->next;
    while(p != NULL){
        if(pre->data == p->data){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 请设计一个算法，在带头结点的无序单链表 L 中删除所有值重复的结点，使值重复的结点只保留一个

```c
void Del_Same(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *r = L->next;
    LNode *pre,*p;
    while(r!=NULL){
        pre = r; // 每次r=r->next都会对p和pre赋值
        p = r->next;
        while(p!=NULL){
            if(p->data == r->data){
                pre->next = p->next;
                free(p);
                p = pre->next;
            }else{
                pre = p;
                p = p->next;
            }
        }
        r = r->next;
    }
}
```

### 设 A 和 B 是两个带头结点的递增有序单链表，请设计一个算法，求单链表 A 与 B 的交集，并生成一个新的单链表 C, 要求不破坏 A、B 的结点。

```c
LinkList Union_Same(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LinkList C = (LinkList)malloc(sizeof(LNode));
    LNode *p = A->next,*q = B->next,*r = C; // 遍历指针
    LNode *s; // 存结点
    while(p != NULL && q != NULL){
        if(p->data > q->data){
            q = q->next;
        }else if(p->data < q->data){
            p = p->next;
        }else{
            s->data = p->data;
            r->next = s;
            r = r->next;
            p = p->next;
            q = q->next;
        }
    }
    r->next = NULL;
    return C;
}
```

### 设 A 和 B 是两个带头结点的递增有序单链表，请设计一个算法，求单链表 A 与 B 的交集，并存放于 A 链表中，其它结点均释放其空间。

```c
LinkList Union_Same(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data > q->data){
            u = q->next;
            free(q);
            q = u;
        }else if(p->data < q->data){
            u = p->next;
            free(p);
            p = u;
        }else{
            r->next = p;
            p = p->next;
            u = q->next;
            free(q);
            q = u;
        }
    }
    while(p != NULL){
        u = p->next;
        free(p);
        p = u;
    }
    while(q != NULL){
        u = q->next;
        free(q);
        q = u;
    }
    r->next = NULL; // 尾指针置空
    free(B); // 释放头结点
    return A;
}
```

### 设 A 和 B 是两个带头结点的递增有序单链表，请设计一个算法，将 A 和 B 两个单链表归并为一个带头结点的非递减有序单疑表，要求利用原来两个单链表的结点组成归并后的单链表。

```c
LinkList Merge(LinkList A,LinkList B){
    if(A->next == NULL &&　Ｂ->next = NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    while(p != NULL && q != NULL){
        if(p.data >= q.data){
            r->next = q;
            r = q;
            q = q->next;
        }else{
            r->next = p;
            r = p;
            p = p->next;
        }
    }
    while(p->next != NULL){
        r->next = p;
        r = p;
        p = p->next;
    }
    while(q->next != NULL){
        r->next = q;
        r = q;
        q = q->next;
    }
    r->next = NULL;
    free(B);
    return A;
}
```

### 设 A 和 B 是两个带头结点的递增有序单链表，请设计一个算法，将 A 和 B 两个单链表归并为一个带头结点的非递增有序单链表，要求利用原来两个单链表的结点组成归并后的单链表。

```c
LinkList Merge(LinkList A,LinkList B){
    if(A->next == NULL && B->next ==NULL){
        return;
    }
    LNode *p = A->next,*q = B->next,*r;
    A->next = NULL;
    while(p != NULL && q != NULL){
        if(p->data >= q->data){
            r = q->next;
            q->next = A->next;
            A->next = q;
            q = r;
        }else{
            r = p->next;
            p->next = A->next;
            A->next = p;
            p = r;
        }
    }
    while(p->next != NULL){
        r = p->next;
        p->next = A->next;
        A->next = p;
        p = r;
    }
    while(q->next != NULL){
        r = q->next;
        q->next = A->next;
        A->next = q;
        q = r;
    }
    free(B);
    return A;
}
```

### 设 A 和 B 是两个带头结点的递增有序单链表，请设计一个算法，求单链表 A 与 B 的差集，并返回差集链表。链表 A 与 B 的差集定义为：在链表 A 中存在但不在链表 B 中存在的所有结点的集合。要求利用原来两个单链表的结点组成差集链表，其它结点均释放其空间。

```c
LinkList Diff(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data < q->data){
            r->next = p;
            p = p->next;
        }else if(p->data > q->data){
            u = q->next;
            free(q);
            q = u;
        }else{
            u = p->next;
            free(p);
            p = u;
            u = q->next;
            free(q);
            q = u;
        }
    }
    while(p->next != NULL){
        r->next = p;
        p = p->next;
    }
    while(q->next != NULL){
        u = q->next;
        free(q);
        q = u;
    }
    r->next = NULL;
    free(B);
    return A;
}
```

### 两个整数序列 A ={a1, a2, a3,…, am}和 B ={b1, b2, b3,…, bn}已经存入两个带头结点的单链表中请设计一个算法，判断序列 B 是否是序列 A 的连续子序列。

```c
bool Pattern(LinkList A,LinkList B){
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data == q->data){
            p = p->next;
            q = q->next;
        }else{
            pre = pre->next;
            p = pre;
            q = B->next;
        }
    }
    if(q == NULL){
        return true;
    }else{
        return false;
    }
}
```

### 通常单链表尾结点指针域为 NULL, 而单链表有环，是指单链表最后一个结点的指针指向了链表中的某个结点。请设计一个算法，判断一个带头结点的单链表 L 是否有环，如果有环，返回环的入口结点位置，如果没有，返回 NULL。

```c
// 有环无环:快慢指针问题    找到相遇点:数学问题 -> a=nr-x
LinkList FindLoop(LinkList L){
    if(L->next == NULL){
        return NULL;
    }
    LNode *slow = L,*fast = L;
    while(fast != NULL || fast->next != NULL){
        if(fast != slow){
            fast = fast->next->next;
            slow = slow->next;
        }else{
            break;
        }
    }
    LNode *p = L;
    LNode *q = slow;
    while(p != q){
        p = p->next;
        q = q->next;
    }
    return p;
}
```

### 有两个带头结点的非空循环单链表 h1 和 h2, 请设计一个算法，将链表 h2 链接到链表 h1 之后，要求链接后的链表仍是一个带头结点的循环单链表。

```c
LinkList Link(LinkList h1,LinkList h2){
    LNode *p = h1->next,*q = h2->next;
    while(p->next != h1){
        p = p->next;
    }
    while(q->next != h2){
        q = q->next;
    }
    p->next = h2->next;
    q->next = h1;
    free(h2);
}
```

### 有一个带头结点的循环单链表 L, 链表 L 中含有三类字符的数据元素（如：字母字符、数字字符和其它字符)，请设计一个算法，将链表拆分为三个不带头结点的循环单链表，其中每个循环单链表均只含一类字符。

```c
void Split(LinkList L, LinkList &A, LinkList &B, LinkList &C){
    A = (LinkList)malloc(sizeof(LNode));
    B = (LinkList)malloc(sizeof(LNode));
    C = (LinkList)malloc(sizeof(LNode));
    LNode *p = L->next,*ra = A,*rb = B,*rc = C;
    while(p->next != L){
        if(p->data > 'a' && p->data < 'z' || p->data > 'A' && p->data < 'Z'){
            ra->next = p;
            ra = ra->next;
        }else if(p->data > '0' && p->data < '9'){
            rb->next = p;
            rb = rb->next;
        }else{
            rc->next = p;
            rc = rc->next;
        }
        p = p->next;
    }
    ra->next = A;
    rb->next = B;
    rc->next = C;
    free(L);
}
```

### 有一个不带头结点的单链表 L, L 中各个结点的值都不相同，请设计一个算法，删除链表 L 中的最小值结点。

法一:

```c
void Del_Min(LinkList &L){
    if(L == NULL){
        return;
    }
    LNode *pre,*p = L;
    LNode *premin,*minp = L;
    while(p != NULL){
        if(p->data < minp->data){
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    if(minp == L){
        L = L->next;
        free(minp);
    }else{
        minpre->next = minp->next;
        free(minp);
    }
}
```

法二:

```c
void Del_Min(LinkList &L){
    if(L == NULL){
    	return;
    }
    LinkList head = (LinkList)malloc(sizeof(LNode));
    head->next = L;
    LNode *p = L,*pre = head;
    LNode *minp = p,*premin = pre;
    while(p != NULL){
        if(p->data <= minp->data){
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    minpre->next = minp->next;
    free(minp);
    L = head->next;
    free(head);
}
```

### 设将 n(n > 1)个整数存放到不带头结点的单链表 L 中，设计算法将 L 中保存的序列循环右移 k(0 < k < n)个位置。例如，若 k = 1, 则将链表{0,1,2,3}变为{3,0,1,2}。

```c
LinkList Move_k(LinkList L,int k){
    LNode *p = L;
    int len = 1;
    while(p->next != NULL){
        p = p->next;
        len++;
    }
    p->next = L;
    for(int i = 0;i < len-k;i++){
        p = p->next;
    }
    L = p->next;
    p->next = NULL;
    return L;
}
```

### 设有一个不带头结点的长度为(n 为偶数)的非空单链表，且结点值都大于 0，设计算法求这个单链表的最大孪生和。孪生和定义为二个结点值与其孪生结点值之和，对于第 i 个结点（从 0 开始）其孪生结点为第 n-i-1 个结点。

```c
// 快慢指针法
int Sum_Max(LinkList L){
    LNode *slow = L,*fast = L;
    while(fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;
    }
    // 将后半部分逆置
    LNode *p = slow->next,*q; // q是防断链指针
    slow->next = NULL;
    while(q != NULL){
        q = p->next;
        p->next = slow->next;
        slow->next = p;
    }
    p = L;
    q = slow->next;
    int max = p->data + q->data;
    while(q != NULL){
        if((p->data + q->data) > max){
            max = p->data + q->data;
        }
        p = p->next;
        q = q->next;
    }
    return max;
}
```

### (约瑟夫环)有 n 个人围成一个圈，他们的编号为 1~n。现在要求从第 1 个人开始报数，数到 m 的人出列，出列后的下一个人继续从 1 开始报数，同样数到 m 的人出列，一直重复此过程，直到圈中只剩下最后一个人，返回其编号。

```c
int Joesphus(LinkList L,int m){
    // 初始化指针
    LNode *p = L,*q = L;
    while(q->next != L){
        q = q->next;
    }
    while(p->next != p){
        for(int i = 1; i < m; i++){
            pre = p;
            p = p->next;
        }
        pre->next = p->next;
        free(p);
        p = pre->next;
    }
    return p->data;
}
```

### 双链表的结构体定义。

```c
typedef struct DNode{
    int data;
    struct DNode *prior,*next;
} DNode, *DLinkList;
```

### 在一个带头结点的非递减有序双链表中插入一个值为 x 的新结点，使得插入新结点后链表依然非递减有序。

```c
void ListInsert(LinkList L, int x){
    DNode *p = L->next,*pre = L;
    while(p->data < x){
        pre = p;
        p = p->next;
    }
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = x;
    s->prior = pre;
    pre->next = s;
    s->next = p;
    if(p != NULL){ // 新插入的结点后面可能为空
        p->prior = s;
    }
}
```

### 有一个带头结点的双链表 L, L 中各个结点的值都不相同，请设计一个算法，删除链表 L 中的最小值结点。

```c
void Del_Min(DLinkList L){
    DNode *p = L->next,*pre = L;
    DNode *minp = L->next,*minpre = L;
    while(p != NULL){
        if(p->data < minp->data){
            minp = p;
        }
        pre = p;
        p->next;
    }
    minpre->next = minp->next;
    if(minp->next != NULL){
        minp->next->prior = minpre;
    }
    free(minp);
}
```

### 请设计一个算法，判断带头结点的循环双链表 L 是否对称

```c
bool Asymmetries(DLinkList L){
    if(L->next == L || L->next->next == L){
        return false;
    }
    DNode *p = L->next,*q = L->prior;
    while(p != q && q->next != p){
        if(p->data == q->data){
            p = p->next;
            q = q->next;
        }else{
            return false;
        }
    }
    return true;
}
```

### 有一个带头结点的双链表 L, L 中各个结点的值都不相同，请设计一个算法，将链表 L 中的最大值结点移动到最前面。

```c
void Move_Max(DLinkList L){
    if(L->next == NULL){
        return;
    }
    DNode *pre = L,*p = L->next;
    DNode *maxp = p,*maxpre = pre;
    while(p != NULL){
        if(p->data > maxp->data){
            maxp = p;
            maxpre = pre;
        }
        pre = p
        p = p->next;
    }
    DNode q = L->next;
    if(maxp = q){
        return;
    }
    maxpre->next = maxp->next;
    if(maxp->next != NULL){
        maxp->next->prior = maxpre;
    }
    maxp->prior = L;
    L->next = maxp;
    maxp->next = q;
    q->prior = maxp;
}
```

### 设有一个带头结点的非循环双链表 L, 其每个结点除了有 prior、data 和 next 域外，还有一个访问频度域 freq, 其值均初始化为 0。L 中各个结点的值都不相同，每当在链表中执行一次 Locate(L, x)运算时，令值为 x 的结点中 freq 域的值增 1，并使此链表中的结点保持按访问频度递减的顺序排列，且最近访问的结点排在频度相同的结点之前，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的 Locate(L, x)函数，返回找到结点的地址，类型为指针型。

```c
DNode Locate(DLinkList L, int x){
    if(L->next == NULL){
        return NULL;
    }
    DNode *p = L->next,*pre = L;
    while(p != NULL){
        if(p->data == x){
            break;
        }
        pre = p;
        p = p->next;
    }
    if(p->prior->data = p->data || p->prior = L){
        return p;
    }
    pre->next = p->next;
    if(p->next != NULL){
        p->next->prior = pre;
    }
    DNode q = L->next;
    pre = L;
    while(q->data > p->data){
        pre = q;
        q = q->next;
    }
    p->prior = pre;
    pre->next = p;
    p->next = q;
    q->prior = p;
    return p;
}
```

### 有一个不带头结点的单链表 L, L 中各个结点的值都不相同，请设计一个递归算法，查找链表 L 中的最小值结点。

```c
DNode *Find_Min(DNodeList L){
    if(L == NULL || L->next == NULL){
        return L;
    }
    DNode *p = Find_Min(L->next);
    if(p->data > L){
        return L;
    }{
        return p;
    }
}
```

### 栈的结构体定义及基本操作。

```c
#define MaxSize 50
typedef struct{
    int data[MaxSize];
    int top;
} Stack;

void InitStack(Stack &S){
    S.top = -1;
}
```

### 有一个带头结点的单链表 L, 结点结构由 data 和 next 两个域构成，其中 data 域为字符型。试设计一个算法判断该链表的全部 n 个字符是否中心对称。例如：xyx、yyx 都是中心对称。

```c
int Func(LinkList L,int x){
    char s[n/2];
    LNode *p = L->next;
    int i;
    for(i = 0;i < n/2; i++){
        s[i] = p->next;
    }
    if(n % 2 == 1){
        p = p->next;
    }
    while( p != NULL){
        if(p->data != s[i].data){
            return 0;
        }
        p = p->next;
        i--;
    }
    return 1;
}
```

### 假设一个算术表达式中包含小括号和中括号 2 种类型的括号，编写一个算法来判别表达式中的括号是否配对，假设算术表达式存放于字符数组中，以字符“\0”作为算术表达式的结束符。

```c
int BracketCheck(char a[]){
    Stack S;
    InitStack(S);
    char x;
    for(int i,a[i] != '\n', i++){
        switch(a[i]){
            case '(':
                Push(S, a[i]);
                break;
            case '[':
                Push(S,a[i]);
                break;
            case ')':
                if(IsEmpty(S)) return 0; // 每次出栈之前记得判空
                Pop(S, x);
                break;
            case ']':
                if(IsEmpty(S)) return 0;
                Pop(S, x);
                break;
            default:
                break;
        }
    }
    if(IsEmpty(S)){
        return 1;
    }else{
        return 0;
    }
}
```

### 有两个栈 s1、s2 都采用顺序栈方式，并共享一个存储区 [0，...，maxsize-1], 为了尽量利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式。试设计写出此栈的定义和 s1、s2 有关入栈和出栈的操作算法。

```c
```

