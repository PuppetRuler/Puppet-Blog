---
title: 408代码题学习笔记
description: 使用资料:B站-阿辉不会敲代码
hidden: true
tags:
  - 408
  - 数据结构
---
## 顺序表

### 顺序表的定义

#### 静态定义顺序表

```c
#define MaxSize 100
typedef struct SqList{
    int data[MaxSize];
    int length;
} SqList;

SqList L;
L.data[0] = 0;
```

#### 动态定义顺序表

```c
typedef struct {
    int *data;
    int MaxSize,length;
} SqList;

SqList L2;
L2.data = (int*)malloc(sizeof(int)*L2.MaxSize);
L2.data[0] = 1;
```

### 顺序表的遍历

```c
void ListVisit(SqList L){
    if(L.length == 0){
        return;
    }
    for(int i = 0; i < L.length; i++){
        printf("%d", L.data[i]);
    }
}
```

### 假设有一个顺序表L,请设计一个算法，查找顺序表L中第一个值为x的元素，若查找成功，则返回其位序，若查找失败，则返回0。

```c
int Search_X(SqList L,int x){
    if(L.length == 0){
        return 0;
    }
    for(int i = 0; i < L.length; i++){
        if(x == L.data[i]){
            return i+1;
        }
    }
    return 0;
}
```

### 假设有一个顺序表L,其存储的所有数据元素均为非0整数，请设计一个算法，查找L中第i个元素并返回其值。

```c
int Search_I(SqList L, int i){
    if(L.length == 0){
        return 0;
    }
    // 合法
    if(i <= L.length && i > 0){
        return L.data[i-1];
    }
    // 非法
    return 0;
}
```

### 假设有一个顺序表L,请设计一个算法，在L的第i个位置插入新元素x。若不能正常插入，则返回false,表示插入失败；若能够正常插入，则在顺序表L中的第i个位置插入新元素x,返回 true,表示插入成功。

```c
bool ListInsert(SqList &L,int i,int x){ // 改变L需要加&
    if(i < 1 || i>L.length || L.MaxSize == L.length){
        return false;
    }
    // 从后往前遍历
    for(j = L.length;j >= i; j--){
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = x;
    L.length++;
    return true;
}
```

### 假设有一个非空顺序表L,其中的元素非递减有序排列，请设计一个算法在插入元素x后保持该顺序表仍然非递减有序排列，假设插入操作肯定成功，插入成功后返回插入元素所在位置。

```c
int ListInsert(SqList &L, int x){
    int i;
    for(i = L.length; i > 0 && L.data[i-1]>=x; i--){
        L.data[i] = L.data[i-1];
    }
    L.data[i+1] = x;
    L.length++;
    return i+1;
}
```

另有

```c
int ListInsert(SqList &L, int x){
    int i;
    // 找到插入位置i
    for(i = 0; i < L.length; i++){
        if(L.data[i] > x){
            break;
        }
    }
    // 移动i+1后面的元素
    for(int j = L.length; j>=i+1; j--){
        L.data[j] = L.data[j-1];
    }
    return i;
}
```

### 删除顺序表L中第i个位置的元素，若删除失败，则返回false;若删除成功，则将被删元素的值赋给引用参数x,然后返回true。

```c
bool Delete_I(SqList &L, int &x, int i){
    if(L.length == 0 || i < 1 || i > L.length){
        return false;
    }
    x = L.data[length-1];
    for(int j = i; j < L.length; j++){
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}
```

### 假设有一个顺序表L,L有最小值且最小值唯一，请设计一个算法删除L中的最小值元素并由函数返回被删元素的值。

```c
int Delete_min(SqList &L){
    int min = L.data[0]; // 最小值是谁
    int pos = 0; // 初始位置是哪
    for(int i = 1; i < L.length; i++){
        if(min > L.data[i]){
            min = L.data[i];
            pos = i;
        }
    }
    for(int j = pos; j < L.length; j++){
        L.data[j] = L.data[j+1];
    }
    L.length--;
    return min;
}
```

### 假设有一个顺序表L,请编写一个时间复杂度为O(以、空间复杂度为O(1)的算法，删除顺序表L中所有值为x的元素。

```c
// 排队法
void Del_x(SqList &L,int x){
    if(L.length == 0){
        return;
    }
    int j = 0;
    for(int i = 0;i <= L.length;i++){
        if(L.data[i] != x){
            L.data[j] = L.data[i];
            j++;
        }
    }
    L.length = j;
}
```

### 假设有一个顺序表L,请设计一个算法删除L中元素值在给定值s与t之间（包含s和t,要求s<t)的所有元素，若顺序表为空或给定的s和t值不合理，则返回false,若执行成功则返回true。

```c
// 计数法
bool Delete_Between(SqList &L, int s, int t){
    if(L.length == 0 || s >=t || s < 1 || t >= L.length){
        return false;
    }
    int p = 0;
    for(int i = 0; i >= 0; i++){
        if(L.data[i] >= s && L.data[i] <= t){
            p++;
        }else {
            L.data[p] = L.data[i];
        }
    }
    L.length = L.length - p;
    return true;
}
```

### 请设计一个算法，在一个有序顺序表中删除所有值重复的元素，使该顺序表中所有元素的值均不同

```c
void Del_Iterate(SqList &L){
    if(L.length <= 1){
        return;
    }
    int j = 1;
    for(int i = 1; i < L.length; i++){
        if(L.data[i] != L.data[i-1]){
            L.data[j] = L.data[i];
        }
    }
    L.length = j;
}
```

### 请设计一个算法，在一个无序顺序表中删除所有值重复的元素，使该顺序表中所有元素的值均不同且删除后的元素间相对位置保持不变。

```c
// 排队法
void Del_Iterate(SqList &L){
    if(L.length <= 1){
        return;
    }
    int k = 1; // 新顺序表的长度
    int j; // 让第一层循环能够获取j
    for(int i = 1; i <= L.length; i++){
        for(j = 1; j < i; j++){
            if(L.data[i] == L.data[j]){
                break; // 停止比较
            }
        }
        if(j == i){ // 没有重复值
            L.data[k] = L.data[i]; // 重排
            k++;
        }
    }
    L.length = k;
}
```

### 请设计一个尽可能高效的算法，将顺序表L中的所有元素逆置，要求算法的空间复杂度为O(1)

```c
void Reverse(SqList &L){
    if(L.length == 0){
        return;
    }
    for(int i = 0,j = L.length - 1; i < j; i++,j--){ // 定义双变量
        temp = L.data[i];
        L.data[i] = L.data[j];
        L.data[j] = temp;
    }
}
```

### 已知一个一维数组A[m+n]中依次存放了两个线性表(a1,a2,…,am)和(b1,b2,…,bn),请设计一个算法，将数组中的两个线性表位置互换，即设计一个算法将原数组(a1,a2,…,am,b1,b2,…,bn)变为(b1,b2,…,bn,a1,a2,…,am)。

法一:

```c
void Swap(int A[], int m, int n){
    int B[m+n];
    for(int i = 0, i < m+n, i++){
        B[i] = A[i];
    }
    for(int i = m, i < m+n, i++){
        A[i - m] = B[m];
    }
    for(int i = 0; i < m; i++){
        A[i + m] = B[i];
    }
}
```

法二:

```c
// 三次逆置,无辅助数组
void Reverse(int A[], int low, int high){
    int temp;
    for(int i = low, int j = high, i < j, i++,j--){
        temp = A.data[i];
        A.data[i] = A.data[j];
        A.data[j] = temp;
    }
}

void Swap(int A[], int m, int n){
    Reverse(A[], 0, m-1);
    Reverse(A[], m, m+n-1);
    Reverse(A[], 0, m+n-1);
}
```

### 现有两个非递减有序的顺序表A和B,请设计一个算法，将两个顺序表A和B合并为一个新的<span style="color:#FF0000;">非递减</span>有序顺序表C。

```c
// 这是题目给出的表的结构
typedef struct {
    int *data;
    int length,MaxSize;
} SqlList;

void Merge(SqlList A, SqList B, SqList &C){
    if(A.length == 0 && B.length == 0 || A.length+B.length > C.MaxSize){
        return false;
    }
    int i=0,j=0,k=0; // 循环变量
    while(i < A.length && j < B.length){
        if(A.data[i] <= B.data[j]){
            C.data[k] = A.data[i];
            k++;
            i++;
        }else {
            C.data[k] = B.data[j];
            k++;
            j++;
        }
    }
    while(i < A.length){
        C.data[k] = A.data[i];
        k++;
        i++;
    }
    while(j < B.length){
        C.data[k] = B.data[j];
        k++;
        j++;
    }
    C.length = k;
    return true;
}
```

### 现有两个非递减有序的顺序表A和B,请设计一个算法，将两个顺序表A和B合并为一个新的<span style="color:#FF0000;">非递增</span>有序顺序表C。

```c
void Merge(SqlList A, SqList B, SqList &C){
    if(A.length == 0 && B.length == 0 || A.length+B.length > C.MaxSize){
        return false;
    }
    int i = A.length - 1;
    int j = B.length - 1;
    int k = 0;
    while(i >=0 && j >=0){
        if(A.data[i] >= B.data[j]){
            C.data[k] = A.data[i];
            k++;
            i--;
        }else {
            C.data[k] = B.data[j];
            k++;
            j--;
        }
    }
    while(i >= 0){
        C.data[k] = A.data[i];
        k++;
        i--;
    }
    while(j >= 0){
        C.data[k] = B.data[j];
        k++;
        j--;
    }
    C.length = k;
    return true;
}
```

### 给定三个序列A、B、C,三个序列的长度均n为且每个序列都是递增的，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。例如，数组A为{4,2,3,6}，数组B为{-5,0,2,6}，数组C为{1,2,4,6}，则逐行输出2和6。

```c
// 暴力解就是3个for循环
// ...
//较小值向较大值靠拢
int max(int A, int B, int C){
    int max;
    if(A > B){
        max = A;
    } else {
        max = B;
    }
    if(max > C){
        return max;
    } else {
      return C;  
    }
}

void PrintSame(int A[], int B[], int C[]){
    int i=0,j=0,k=0;
    int m;
    while(i<A.length && j<B.length && k<C.length){
        if(A.data[i] == B.data[j] && A.data[i] == C.data[k]){
            printf("%d/n",A.data[i]);
        }
        m = max(A.data[i],B.data[j],C.data[k])
        if(A.data[i]<m){
            i++;
        }
        if(B.data[j]<m){
            j++;
        }
        if(C.data[k]<m){
            k++;
        }
    }
}
```

## 链表

### 单链表的结构体定义

```c
typedef struct LNode{
    int data;
    struct LNode *next;
} LNode,*LinkList;

// struct LNode -> Lnode
// struct LNode* -> LinkList
// LinkList p -> LNode *p
    
// 带头结点
void InitList1(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
}

bool IsEmptyList1(LinkList L){
    if(L->next == NULL){
        return true;
    }else {
        return false;
    }
}
// 不带头结点
void InitList2(LinkList &L){
    L = NULL;
}

bool IsEmptyList2(LinkList &L){
    if(L == NULL){
        return true;
    }else {
        return false;
    }
}

// 注:链表不存在L.data之类操作
```

### 遍历输出单链表L中的值

```c
void LNodeList(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *p = L->next;
    while(p != NULL){
        printf("%d",p->data);
        p = p->next;
    }
}
```

### 请设计一个算法，查找一个带头结点的单链表L中第i个数据结点的位置，若存在，则返回指向该结点的指针，若不存在，则返回NULL

```c
LNode *Search_i(LinkList L, int i){
    if(L->next == NULL || i < 1){ // 判空
        return;
    }
    LNode *p = L->next;
    int k = 1;
    while(p != NULL){
        if(i = k){
            return p;
        }
        p = p->next;
        k++;
    }
    return NULL; // 说明 i 太大了
}
```

### 计算带头结点的单链表L中数据结点的个数。

```c
int DataNum(LinkList L){
    if(L->next == NULL){
        return 0;
    }
    LNode *p = L->next;
    int k = 0;
    while(p != NULL){
        p = p->next;
        k++;
    }
    return k;
}
```



### 在一个带头结点的非递减有序单链表中插入一个值为x的新结点，使得插入新结点后链表依然非递减有序

```c
void InsertList(LinkList &L, int x){
    LNode *p = L->next, *pre = L;
    while(p != NULL){
        if(p->data > x){
            break;
        }
        pre = p;
        p = p->next;
    }
    LNode *s = (LNode*)malloc(sizeof(LNode));
    s->data = x;
    s->next = p;
    pre->next = s;
}
```

### 采用头插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，头插结束后返回建立的单链表。

```c
LinkList HeadInsert(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    LNode *x
    int i;
    scanf("%d",&i);
    while(i != -1){
        x = (*LNode)malloc(sizeof(LNode));
        x->data = i;
        x->next = L->next;
        L->next = i;
        scanf("%d",&i);
    }
    return L;
}
```

### 采用尾插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，尾插结束后返回建立的单链表。

```c
LinkList TailInsert(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    LNode *r = L; // 尾指针
    LNode *s;
    int x;
    scanf("%d",&x);
    while(x == -1){
        s = (LNode*)malloc(sizeof(LNode)) // 为结点分配内存空间
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL; // 尾结点的next指针置空
    return L;
}
```

### 试编写算法将一个带头结点的单链表L就地逆置，所谓“就地”是指空间复杂度为O(1)。

```C
void Reverse(LinkList &L){
    if(L->next == NULL){
        return;
    }
    LNode *p = L->next,*r;
    L->next = NULL; // 将尾结点next置空
    while(r->next = NULL){
        r = p->next; // 防断链指针
        p->next = L->next;
        L->next = p;
        p = r;
    }
}
```

### 将一个带头结点的单链表A分解为两个带头结点的单链表A和B,使得A表中含有原表中位序为奇数的结点，B表中含有原表中位序为偶数的结点，且保持结点间相对顺序不变，最后返回B表，

```c
LinkList Reverse(LinkList &L){
    if(L->next = NULL){
        return NULL;
    }
    LinkList B = (LinkList)malloc(sizeof(LNode));
    LNode *p = A->next;
    LNode *ra = A,*rb = B;
    while(p != NULL){
        ra->next = p;
        ra = p;
        p = p->next;
        if(p != NULL){ // 单链表奇数或偶数
            rb->next = p;
            rb = p;
            p = p->next;
        }
    }
    ra->next = NULL; // 尾指针置空
    rb->next = NULL;
}
```

### 编写算法将一个带头结点的单链表A={a1,b1,a2,b2,...,an,bn}分解为两个带头结点的单链表A和B使得A={a1,a2,…,an},B={bn,…,b2,b1},原A表中结点个数不一定为偶数。

```c
// 对A使用尾插法(正序),对B使用头插法(逆序)
LinkList Split(LinkList A){
    if(A->next == NULL){
        return NULL;
    }
    LinkList B = (LNode *)malloc(sizeof(LNode));
    B->next = NULL;
    LNode *p = A->next,*r = A,*q;
    while(p != NULL){
        r->next = p;
        r = p;
        p = p->next;
        while(p != NULL){
            q = p->next; // 防断链指针
            p->next = B->next;
            B->next = p;
            p = q;
        }
    }
    r->next = NULL;
    return B;
}
```

### 将一个带头结点的单链表L分解为两个带头结点的单链表A和B,使得A表中含有原表中数据域为奇数的结点，而B表中含有原表中数据域为偶数的结点，且保持相对顺序不变，最后删除单链表L的头结点。

```c
void Split(LinkList L,LinkList &A,LinkList &B){
    if(L->next == NULL){
        return;
    }
    // 分配空间
    A = (LinkList)malloc(sizeof(LNode));
    B = (LinkList)malloc(sizeof(LNode));
    // 定义指针
    LNode *p = L->next,*ra = A,*rb = B;
    while(p != NULL){
        if(p->data % 2 != 0){
            ra->next = p;
            ra = p;
        }else{
            rb->next = p;
            rb = p;
        }
        p = p->next;
    }
    ra->next = NULL;
    rb->next = NULL;
    free(L);
}
```

### 有一个带头结点单链表L，L中各个结点的值都不相同，请设计一个算法，删除链表L中的最小值结点。

```c
void Del_Min(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *minpre = L,*minp = L->next;
    LNode *pre = L->next,*p = pre->next;
    while(p != NULL){
        if(p->data < minp->data){
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    minpre->next = minp->next;
    free(minp);
}
```

### 请设计一个算法，在带头结点的单链表L中删除所有值为x的结点，并释放其空间。

```c
void Del_x(LinkList L, int x){
    if(L->next == NULL){
        return;
    }
    LNode *pre = L,p = L->next;
    while(p != NULL){
        if(p->data = x){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 请设计一个算法，在带头结点的单链表L中删除所有数据域的值介于给定的两个值之间的结点，并释放其空间。

```c
void Del_min_max(LinkList L,int min,int max){
    if(L->next == NULL || min >= max){
        return;
    }
    LNode *pre = L,*p = L->next;
    while(p != NULL){
        if(p->data >= min && p->data <= max){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 请设计一个算法，在带头结点的非递减有序单链表L中删除所有值重复的结点，使值重复的结点只保留一个。

```c
void Del_Same(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *pre = L->next,*p = pre->next;
    while(p != NULL){
        if(pre->data == p->data){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 请设计一个算法，在带头结点的无序单链表L中删除所有值重复的结点，使值重复的结点只保留一个

```c
void Del_Same(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *r = L->next;
    LNode *pre,*p;
    while(r!=NULL){
        pre = r; // 每次r=r->next都会对p和pre赋值
        p = r->next;
        while(p!=NULL){
            if(p->data == r->data){
                pre->next = p->next;
                free(p);
                p = pre->next;
            }else{
                pre = p;
                p = p->next;
            }
        }
        r = r->next;
    }
}
```

### 设A和B是两个带头结点的递增有序单链表，请设计一个算法，求单链表A与B的交集，并生成一个新的单链表C,要求不破坏A、B的结点。

```c
LinkList Union_Same(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LinkList C = (LinkList)malloc(sizeof(LNode));
    LNode *p = A->next,*q = B->next,*r = C; // 遍历指针
    LNode *s; // 存结点
    while(p != NULL && q != NULL){
        if(p->data > q->data){
            q = q->next;
        }else if(p->data < q->data){
            p = p->next;
        }else{
            s->data = p->data;
            r->next = s;
            r = r->next;
            p = p->next;
            q = q->next;
        }
    }
    r->next = NULL;
    return C;
}
```

### 设A和B是两个带头结点的递增有序单链表，请设计一个算法，求单链表A与B的交集，并存放于A链表中，其它结点均释放其空间。

```c
LinkList Union_Same(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data > q->data){
            u = q->next;
            free(q);
            q = u;
        }else if(p->data < q->data){
            u = p->next;
            free(p);
            p = u;
        }else{
            r->next = p;
            p = p->next;
            u = q->next;
            free(q);
            q = u;
        }
    }
    while(p != NULL){
        u = p->next;
        free(p);
        p = u;
    }
    while(q != NULL){
        u = q->next;
        free(q);
        q = u;
    }
    r->next = NULL; // 尾指针置空
    free(B); // 释放头结点
    return A;
}
```

### 设A和B是两个带头结点的递增有序单链表，请设计一个算法，将A和B两个单链表归并为一个带头结点的非递减有序单疑表，要求利用原来两个单链表的结点组成归并后的单链表。

```c
LinkList Merge(LinkList A,LinkList B){
    if(A->next == NULL &&　Ｂ->next = NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    while(p != NULL && q != NULL){
        if(p.data >= q.data){
            r->next = q;
            r = q;
            q = q->next;
        }else{
            r->next = p;
            r = p;
            p = p->next;
        }
    }
    while(p->next != NULL){
        r->next = p;
        r = p;
        p = p->next;
    }
    while(q->next != NULL){
        r->next = q;
        r = q;
        q = q->next;
    }
    r->next = NULL;
    free(B);
    return A;
}
```

### 设A和B是两个带头结点的递增有序单链表，请设计一个算法，将A和B两个单链表归并为一个带头结点的非递增有序单链表，要求利用原来两个单链表的结点组成归并后的单链表。

```c
LinkList Merge(LinkList A,LinkList B){
    if(A->next == NULL && B->next ==NULL){
        return;
    }
    LNode *p = A->next,*q = B->next,*r;
    A->next = NULL;
    while(p != NULL && q != NULL){
        if(p->data >= q->data){
            r = q->next;
            q->next = A->next;
            A->next = q;
            q = r;
        }else{
            r = p->next;
            p->next = A->next;
            A->next = p;
            p = r;
        }
    }
    while(p->next != NULL){
        r = p->next;
        p->next = A->next;
        A->next = p;
        p = r;
    }
    while(q->next != NULL){
        r = q->next;
        q->next = A->next;
        A->next = q;
        q = r;
    }
    free(B);
    return A;
}
```

### 设A和B是两个带头结点的递增有序单链表，请设计一个算法，求单链表A与B的差集，并返回差集链表。链表A与B的差集定义为：在链表A中存在但不在链表B中存在的所有结点的集合。要求利用原来两个单链表的结点组成差集链表，其它结点均释放其空间。

```c
LinkList Diff(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data < q->data){
            r->next = p;
            p = p->next;
        }else if(p->data > q->data){
            u = q->next;
            free(q);
            q = u;
        }else{
            u = p->next;
            free(p);
            p = u;
            u = q->next;
            free(q);
            q = u;
        }
    }
    while(p->next != NULL){
        r->next = p;
        p = p->next;
    }
    while(q->next != NULL){
        u = q->next;
        free(q);
        q = u;
    }
    r->next = NULL;
    free(B);
    return A;
}
```

### 两个整数序列A={a1,a2,a3,…,am}和B={b1,b2,b3,…,bn}已经存入两个带头结点的单链表中请设计一个算法，判断序列B是否是序列A的连续子序列。

```c
bool Pattern(LinkList A,LinkList B){
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data == q->data){
            p = p->next;
            q = q->next;
        }else{
            pre = pre->next;
            p = pre;
            q = B->next;
        }
    }
    if(q == NULL){
        return true;
    }else{
        return false;
    }
}
```

### 通常单链表尾结点指针域为NULL,而单链表有环，是指单链表最后一个结点的指针指向了链表中的某个结点。请设计一个算法，判断一个带头结点的单链表L是否有环，如果有环，返回环的入口结点位置，如果没有，返回NULL。

```c
// 有环无环:快慢指针问题    找到相遇点:数学问题 -> a=nr-x
LinkList FindLoop(LinkList L){
    if(L->next == NULL){
        return NULL;
    }
    LNode *slow = L,*fast = L;
    while(fast != NULL || fast->next != NULL){
        if(fast != slow){
            fast = fast->next->next;
            slow = slow->next;
        }else{
            break;
        }
    }
    LNode *p = L;
    LNode *q = slow;
    while(p != q){
        p = p->next;
        q = q->next;
    }
    return p;
}
```

